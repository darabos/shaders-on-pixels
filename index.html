<div id="palette">
  <span
    v-for="c in colors"
    v-bind:style="'background-color: #' + c.getHexString()"
    v-on:click="colorClicked(c)"
  ></span>
</div>
<canvas id="c" width="480" height="480"></canvas>
<style>
#palette span {
  display: inline-block;
  width: 30px;
  height: 30px;
}
</style>

<script src="three.js"></script>
<script src="vue.js"></script>
<script>

let currentColor = 'black';
const pal = new Vue({
  el: '#palette',
  data: {
    colors: [],
  },
  methods: {
    colorClicked: c => {
      currentColor = c;
    },
  },
});

const palettes = {
  na16: `#8c8fae #584563 #3e2137 #9a6348 #d79b7d #f5edba #c0c741 #647d34 #e4943a #9d303b #d26471 #70377f #7ec4c1 #34859d #17434b #1f0e1c`,
};
function setPalette(p) {
  pal.colors = palettes[p].split(/ /).map(c => new THREE.Color(c));
  currentColor = pal.colors[0];
}
setPalette('na16');

function draw(e) {
  const [x, y] = [Math.floor(e.layerX / 16), Math.floor(e.layerY / 16)];
  data[(x+y*W)*4] = currentColor.r*255;
  data[(x+y*W)*4+1] = currentColor.g*255;
  data[(x+y*W)*4+2] = currentColor.b*255;
  data[(x+y*W)*4+3] = 255;
  texture.needsUpdate = true;
  renderer.render(scene, camera);
}
c.onmousemove = e => e.buttons && draw(e);
c.onmousedown = e => e.buttons && draw(e);

const [W, H] = [30, 30];
const data = new Uint8Array(4 * W * H);
for (let i = 0; i < data.length; ++i) data[i] = i%4 === 3 ? 255 : pal.colors[15].toArray[i%4];
const texture = new THREE.DataTexture(data, W, H);
texture.needsUpdate = true;
camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
scene = new THREE.Scene();
const geometry = new THREE.PlaneGeometry(2, 2);

const DEFAULTSHADER = `
#if defined(VERTEX)
varying vec2 vUv;
void main() {
  vUv = uv;
  gl_Position = vec4(position, 1.0);
}
#endif
#if defined(FRAGMENT)
varying vec2 vUv;
uniform sampler2D Texture;
void main() {
  gl_FragColor = texture2D(Texture, vec2(vUv.x, 1.0-vUv.y));
}
#endif
`;

function makeShader(g) {
  return new THREE.ShaderMaterial({
    uniforms: {
      Texture: { value: texture },
      TextureSize: { value: [30, 30] },
      InputSize: { value: [30, 30] },
      OutputSize: { value: [480, 480] },
      FrameCount: { value: 0 },
      MVPMatrix: { value: [
        1.0, 0.0, 0.0, 0.0,
        0.0, 1.0, 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0,
        0.0, 0.0, 0.0, 1.0 ] },
    },
    vertexShader: '#define VERTEX 1\n' + g,
    fragmentShader: '#define FRAGMENT 1\n' + g,
  });
}
function setShader(m) {
  mesh.material = m;
  renderer.render(scene, camera);
}

SHADERS = 'none xbrz-freescale'.split(/ /);
async function loadShader(g) {
  if (g === 'none') {
    return DEFAULTSHADER;
  } else {
    const r = await fetch(g);
    if (!r.ok) {
      throw new Error('fetch failed');
    }
    return await r.text();
  }
}

const mesh = new THREE.Mesh(geometry, makeShader(DEFAULTSHADER));
scene.add(mesh);
renderer = new THREE.WebGLRenderer({ canvas: c });
renderer.setPixelRatio( window.devicePixelRatio );
renderer.setSize(480, 480);
renderer.render(scene, camera);

loadShader('xbrz-freescale.glsl').then(g => setShader(makeShader(g)));
</script>
