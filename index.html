<select id="shadersdropdown" v-on:change="shaderSelected">
  <option v-for="s in shaders" v-bind:value="s">{{ s }}</option>
</select>
<div id="palette">
  <span
    v-for="c in colors"
    v-bind:style="'background-color: #' + c.getHexString()"
    v-on:click="colorClicked(c)"
  ></span>
</div>
<canvas id="c" width="480" height="480"></canvas>
<style>
#palette span {
  display: inline-block;
  width: 30px;
  height: 30px;
}
</style>

<script src="three.js"></script>
<script src="vue.js"></script>
<script>

let currentColor = 'black';
const pal = new Vue({
  el: '#palette',
  data: {
    colors: [],
  },
  methods: {
    colorClicked: c => {
      currentColor = c;
    },
  },
});

const palettes = {
  na16: `#8c8fae #584563 #3e2137 #9a6348 #d79b7d #f5edba #c0c741 #647d34 #e4943a #9d303b #d26471 #70377f #7ec4c1 #34859d #17434b #1f0e1c`,
};
function setPalette(p) {
  pal.colors = palettes[p].split(/ /).map(c => new THREE.Color(c));
  currentColor = pal.colors[0];
  c.style.backgroundColor = pal.colors[15].getHexString();
}
setPalette('na16');

function draw(e) {
  const [x, y] = [Math.floor(e.layerX / 16), Math.floor(e.layerY / 16)];
  const c = [...currentColor.toArray(), 1];
  let change = false;
  for (let i = 0; i < 4; ++i) {
    if (data[(x+y*W)*4 + i] != c[i]) {
      data[(x+y*W)*4 + i] = c[i]*255;
      change = true;
    }
  }
  if (change) {
    localStorage.setItem('drawing', JSON.stringify([...data]));
    texture.needsUpdate = true;
    renderer.render(scene, camera);
  }
}
c.onmousemove = e => e.buttons && draw(e);
c.onmousedown = e => e.buttons && draw(e);

const [W, H] = [30, 30];
function loadDrawing() {
  try {
    const v = JSON.parse(localStorage.getItem('drawing'));
    console.log(v);
    if (v) return v;
  } catch (e) {}
  return 4 * W * H;
}
const data = new Uint8Array(loadDrawing());
const texture = new THREE.DataTexture(data, W, H);
texture.needsUpdate = true;
camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
scene = new THREE.Scene();
const geometry = new THREE.PlaneGeometry(2, 2);

const DEFAULTSHADER = `
#if defined(VERTEX)
varying vec2 vUv;
void main() {
  vUv = uv;
  gl_Position = vec4(position, 1.0);
}
#endif
#if defined(FRAGMENT)
varying vec2 vUv;
uniform sampler2D Texture;
void main() {
  gl_FragColor = texture2D(Texture, vec2(vUv.x, 1.0-vUv.y));
}
#endif
`;

function makeShader(g) {
  return new THREE.ShaderMaterial({
    uniforms: {
      Texture: { value: texture },
      TextureSize: { value: [30, 30] },
      InputSize: { value: [30, 30] },
      OutputSize: { value: [480, 480] },
      FrameCount: { value: 1 },
      FrameDirection: { value: 1 },
      MVPMatrix: { value: [
        1.0, 0.0, 0.0, 0.0,
        0.0, 1.0, 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0,
        0.0, 0.0, 0.0, 1.0 ] },
    },
    vertexShader: '#define VERTEX 1\n' + g,
    fragmentShader: '#define FRAGMENT 1\n' + g,
  });
}
function setShader(m) {
  mesh.material = m;
  renderer.render(scene, camera);
}

const SHADERS = '-none- omniscale ntsc-adaptive ntsc-gauss ntsc-xot xbrz-freescale triangular'.split(/ /);
SHADERS.sort();
new Vue({
  el: '#shadersdropdown',
  data: {
    shaders: SHADERS,
  },
  methods: {
    shaderSelected: s => {
        console.log(s.target.value);
      loadShader(s.target.value).then(s => setShader(makeShader(s)));
    },
  },
});

async function loadShader(g) {
  if (g === '-none-') {
    return DEFAULTSHADER;
  } else {
    const r = await fetch(g + '.glsl');
    if (!r.ok) {
      throw new Error('fetch failed');
    }
    return await r.text();
  }
}

const mesh = new THREE.Mesh(geometry, makeShader(DEFAULTSHADER));
scene.add(mesh);
renderer = new THREE.WebGLRenderer({ canvas: c });
renderer.setPixelRatio( window.devicePixelRatio );
renderer.setSize(480, 480);
renderer.render(scene, camera);
</script>
